name: Update cloudflared Release

on:
  schedule:
    - cron: "0 */1 * * *"
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Check out the current repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Fetch the latest release info from cloudflare/cloudflared.
      - name: Get latest upstream release info
        id: get_release
        run: |
          echo "Fetching latest release info from cloudflare/cloudflared..."
          release_info=$(curl -s https://api.github.com/repos/cloudflare/cloudflared/releases/latest)
          tag=$(echo "$release_info" | jq -r .tag_name)
          title=$(echo "$release_info" | jq -r .name)
          echo "Latest tag: $tag"
          echo "tag=$tag" >> $GITHUB_OUTPUT
          echo "title=$title" >> $GITHUB_OUTPUT

      # Step 3: Check if the current version already matches the upstream release.
      - name: Check current version
        id: check_version
        run: |
          if [ -f RELEASE_NOTES ]; then
            current_version=$(head -1 RELEASE_NOTES)
          else
            current_version=""
          fi
          echo "Current version: $current_version"
          echo "New version: ${{ steps.get_release.outputs.tag }}"
          if [ "$current_version" = "${{ steps.get_release.outputs.tag }}" ]; then
            echo "Version is already up-to-date. Exiting."
            exit 0
          fi
          echo "New version detected. Proceeding with update."

      # Step 4: Add the upstream remote and fetch the tag, then create a new branch from it.
      - name: Add upstream remote and fetch tag
        run: |
          git remote add upstream https://github.com/cloudflare/cloudflared.git || true
          git fetch upstream tag ${{ steps.get_release.outputs.tag }} --depth=1
          git checkout -b update-cloudflared-${{ steps.get_release.outputs.tag }} FETCH_HEAD

      # Step 5: Push the new branch to our repository.
      - name: Push branch to origin
        run: |
          git push origin update-cloudflared-${{ steps.get_release.outputs.tag }}

      # Step 6: Create a Pull Request from the new branch (head) to kjake/cloudflared:master.
      - name: Create Pull Request from upstream tag branch
        id: create_pr
        uses: peter-evans/create-pull-request@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "Update cloudflared to ${{ steps.get_release.outputs.tag }}"
          body: |
            This PR updates cloudflared to version ${{ steps.get_release.outputs.tag }}.
          base: master
          branch: update-cloudflared-${{ steps.get_release.outputs.tag }}
          labels: automated pr
          assignees: ${{ github.repository_owner }}
          reviewers: ${{ github.repository_owner }}

      # Step 7 (Optional): If the PR is mergeable, auto-merge it.
      - name: Auto-merge Pull Request if mergeable
        if: ${{ steps.create_pr.outputs.pull-request-number }}
        uses: actions/github-script@v6
        with:
          script: |
            const pr_number = parseInt("${{ steps.create_pr.outputs.pull-request-number }}");
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number
            });
            if (pr.mergeable) {
              console.log("PR is mergeable. Merging now...");
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr_number,
                commit_title: pr.title,
                commit_message: pr.body,
                merge_method: "rebase"
              });
            } else {
              console.log("PR is not mergeable at this time.");
            }

      # Step 8 (Optional): If auto-merge was successful, create a GitHub release.
      - name: Create Release
        if: ${{ steps.create_pr.outputs.pull-request-number }}
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.get_release.outputs.tag }}
          release_name: ${{ steps.get_release.outputs.title }}
